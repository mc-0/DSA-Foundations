<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphs - DSA Foundations</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #e6edf3;
            background-color: #0d1117;
            max-width: 1012px;
            margin: 0 auto;
            padding: 16px;
        }
        
        h1 {
            color: #f0f6fc;
            border-bottom: 1px solid #30363d;
            padding-bottom: 0.3em;
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            font-size: 2em;
        }
        
        h2 {
            color: #f0f6fc;
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            font-size: 1.5em;
        }
        
        h4 {
            color: #f0f6fc;
            margin-top: 20px;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 1.1em;
        }
        
        ul, ol {
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        strong {
            font-weight: 600;
            color: #58a6ff;
        }
        
        p {
            margin-bottom: 16px;
        }
        
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 16px 0;
            border-radius: 6px;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: table;
            background-color: #0d1117;
        }
        
        th, td {
            border: 1px solid #30363d;
            padding: 6px 13px;
            text-align: left;
        }
        
        th {
            background-color: #21262d;
            font-weight: 600;
        }
        
        tr:nth-child(2n) {
            background-color: #161b22;
        }
        
        code {
            background-color: rgba(110, 118, 129, 0.4);
            padding: 0.2em 0.4em;
            border-radius: 6px;
            font-size: 85%;
            font-family: ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        a {
            color: #58a6ff;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        .trade-offs-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 16px 0;
        }
        
        .trade-off-box {
            background-color: #161b22;
            padding: 16px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }
        
        .trade-off-box h4 {
            margin-top: 0;
            color: #f0f6fc;
            font-size: 1.1em;
            font-weight: 600;
        }
        
        @media (max-width: 768px) {
            .trade-offs-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <img src="https://github.com/user-attachments/assets/8e18549c-162d-432e-ae01-929637bbc0d8" alt="Graph visualization" />
    
    <h1>Graphs</h1>
    
    <h2>Attributes</h2>
    <ul>
        <li><strong>Vertices (Nodes)</strong>: Graphs are made up of a set of vertices, often representing entities or objects.</li>
        <li><strong>Edges (Links)</strong>: The connections between the vertices, which can be directed or undirected.</li>
        <li><strong>Directed/Undirected</strong>: In a directed graph, edges have a direction, indicating a one-way relationship. In an undirected graph, edges represent a mutual relationship.</li>
        <li><strong>Weighted/Unweighted</strong>: A weighted graph has edges with a cost or value associated with them, whereas in an unweighted graph, all edges are treated equally.</li>
        <li><strong>Degree</strong>: The number of edges connected to a vertex. For directed graphs, this is split into in-degree and out-degree.</li>
        <li><strong>Path</strong>: A sequence of vertices connected by edges. In a simple path, vertices do not repeat.</li>
        <li><strong>Cycle</strong>: A path where the starting and ending vertices are the same. A graph without cycles is called acyclic.</li>
        <li><strong>Connected Components</strong>: In an undirected graph, connected components are groups of vertices where each vertex is reachable from any other vertex in the component.</li>
    </ul>
    
    <h2>Graph Representations</h2>
    
    <h4>Adjacency Lists:</h4>
    <img src="https://github.com/user-attachments/assets/575ea3a9-72d6-4837-8eed-9990ce9e89c6" alt="Adjacency List visualization" />
    <ul>
        <li>A space-efficient way to represent graphs by storing a list of adjacent vertices for each vertex.
            <ul>
                <li>Graph is represented by an array of lists</li>
            </ul>
        </li>
        <li>Each index corresponds to a vertex</li>
        <li>The list at that index contain the vertices connected to it</li>
        <li>For an undirected graph: an edge connecting A &amp; B will be present in A's list &amp; B's list</li>
        <li>For a direct graph, the list at a given index represents the vertices that a particular vertex connects to</li>
    </ul>
    
    <h4>Adjacency Matrix</h4>
    <img src="https://github.com/user-attachments/assets/c7095734-d00e-435a-9f00-7a48971b2f9f" alt="Adjacency Matrix visualization" />
    <ul>
        <li>Represents a graph as a 2D array</li>
        <li>The position (i,j) indicates if an edge connects vertex i &amp; vertex j</li>
        <li>Undirected graphs: The matrix is symmetric</li>
        <li>Directed graphs: The cell (i,j) will contain a 1 (true) or 0 (false), denoting whether an edge connects i to j</li>
        <li>Adjacency Matrix: A 2D matrix representation where cells indicate the presence (and optionally, the weight) of an edge between vertex pairs.</li>
    </ul>
    
    <h2>Operations</h2>
    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>Adjacency List (Time Complexity)</th>
                <th>Adjacency Matrix (Time Complexity)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Add Vertex</strong></td>
                <td><code>O(1)</code></td>
                <td><code>O(V^2)</code></td>
            </tr>
            <tr>
                <td><strong>Add Edge (Unweighted)</strong></td>
                <td><code>O(1)</code></td>
                <td><code>O(1)</code></td>
            </tr>
            <tr>
                <td><strong>Add Edge (Weighted)</strong></td>
                <td><code>O(1)</code></td>
                <td><code>O(1)</code></td>
            </tr>
            <tr>
                <td><strong>Remove Vertex</strong></td>
                <td><code>O(V + E)</code></td>
                <td><code>O(V^2)</code></td>
            </tr>
            <tr>
                <td><strong>Remove Edge</strong></td>
                <td><code>O(degree(v)) ≈ O(E/V)</code> on average, <code>O(V)</code> in worst case</td>
                <td><code>O(1)</code></td>
            </tr>
            <tr>
                <td><strong>Check if Edge Exists</strong></td>
                <td><code>O(degree(v)) ≈ O(E/V)</code> on average, <code>O(V)</code> in worst case</td>
                <td><code>O(1)</code></td>
            </tr>
            <tr>
                <td><strong>Get All Neighbors (Vertex)</strong></td>
                <td><code>O(V)</code> or <code>O(E)</code></td>
                <td><code>O(V)</code></td>
            </tr>
            <tr>
                <td><strong>Space Complexity</strong></td>
                <td><code>O(V + E)</code></td>
                <td><code>O(V^2)</code></td>
            </tr>
            <tr>
                <td><strong>Best For</strong></td>
                <td>Efficient for sparse graphs. More memory efficient with fewer edges relative to the # of vertices</td>
                <td>Efficient for dense graphs. Better when graphs have many edges as checking for the presence of a graph is very quick</td>
            </tr>
        </tbody>
    </table>
    
    <h2>Trade Offs</h2>
    <div class="trade-offs-section">
        <div class="trade-off-box">
            <h4><strong>Adjacency Lists</strong></h4>
            <p><strong>PRO</strong></p>
            <ul>
                <li>More space-efficient for sparse graphs <code>O(V + E)</code></li>
                <li>Faster to iterate over all edges of a vertex</li>
                <li>Easy to store additional information like edge weights</li>
            </ul>
            <p><strong>CON</strong></p>
            <ul>
                <li>Slower to check if an edge exists <code>O(V)</code> in worst case</li>
                <li>Larger graph traversal time (because of linked lists)</li>
                <li>Requires more complex structures to manage nodes</li>
            </ul>
        </div>
        <div class="trade-off-box">
            <h4><strong>Adjacency Matrices</strong></h4>
            <p><strong>PRO</strong></p>
            <ul>
                <li>Faster to check the existence of an edge <code>O(1)</code></li>
                <li>Simple to implement and manage with arrays</li>
                <li>Efficient for dense graphs</li>
            </ul>
            <p><strong>CON</strong></p>
            <ul>
                <li>High space complexity for sparse graphs <code>O(V^2)</code></li>
                <li>Slow for adding/removing vertices <code>O(V^2)</code> reallocation</li>
                <li>Traversal of neighbors takes <code>O(V)</code> for each vertex</li>
            </ul>
        </div>
    </div>
    
    <h2>Common Uses</h2>
    <ul>
        <li><strong>Social Networks</strong>: To model relationships between users (e.g., friendships, followers).</li>
        <li><strong>Transportation Networks</strong>: For routing and pathfinding (e.g., road networks, airline routes).</li>
        <li><strong>Web Graphs</strong>: Representing the structure of the web, where pages are vertices and links are edges.</li>
        <li><strong>Dependency Resolution</strong>: Used in build systems, where nodes represent tasks and edges indicate dependencies.</li>
        <li><strong>Computer Networks</strong>: For routing, where nodes are computers or routers, and edges represent data connections.</li>
        <li><strong>Recommendation Systems</strong>: Nodes are users/items, and edges represent interactions or similarities.</li>
        <li><strong>Biological Networks</strong>: Representing systems like metabolic networks or neural connections.</li>
    </ul>
    
    <h2>Implementations</h2>
    <p><a href="https://github.com/mc-0/DSA/tree/main/src/datastructures/graphs">Graph Implementation</a></p>
</body>
</html>